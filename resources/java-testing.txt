ngOnInit(): void {
  this.analyticalReportService.currentReportId$.pipe(
    takeUntil(this.destroying$),
    // switchMap handles the ID change and fetches metadata in order
    switchMap(id => {
      this.reportId = id;
      console.log('State Change Detected: New ID is', id);

      // Fetch column mappings and groupings first
      return forkJoin({
        cols: makeHttpGetRequest(this.httpClient, './api/report/column-mapping', {
          params: { reportType: this.reportType }
        }),
        groupings: makeHttpGetRequest(this.httpClient, './api/report/grouping-attr', {
          params: { reportType: this.reportType }
        })
      });
    })
  ).subscribe({
    next: (response: any) => {
      // 1. Set the Grid Structure
      this.pivotGroupColDefs = this.gridHelperService.getColModelByReportType(
        response.groupings,
        response.cols
      );

      // 2. Trigger data loading now that structure is ready
      this.loadReport();
    },
    error: (err) => console.error(err)
  });
}

---------

import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class CommonService {
  // Use BehaviorSubject to hold the "Current" DMID state
  private dmidSource = new BehaviorSubject<any>(null);

  // Observable that components will subscribe to
  dmidState$ = this.dmidSource.asObservable();

  // Method to update the DMID from AppComponent
  updateDMID(newId: any) {
    this.dmidSource.next(newId);
  }
}

// Inside your DMID change logic
this.commonService.updateDMID(newSelectedId);

ngOnInit() {
  this.commonService.dmidState$
    .pipe(takeUntil(this.destroying$))
    .subscribe(id => {
      if (id) {
        console.log('DMID Change Detected:', id);
        this.reportId = id; //
        this.loadReport();  // Re-trigger the data fetch
      }
    });
}


ngOnInit() {
  this.commonService.dmidState$
    .pipe(takeUntil(this.destroying$))
    .subscribe(newId => {
      if (newId) {
        this.reportId = newId; //

        // Update the TMID/DMID inside the additional parameters array
        this.updatePayloadParams(newId);

        // Reload the report with the new parameters
        this.loadReport(); //
      }
    });
}

private updatePayloadParams(newId: any) {
  if (this.additionalRequestPayloadParams && this.additionalRequestPayloadParams.length > 0) {
    // We create a new array reference to ensure Angular detection triggers
    this.additionalRequestPayloadParams = this.additionalRequestPayloadParams.map(param => {
      // Check for your specific key (e.g., 'tmid', 'dmid', or 'id')
      if (param.key === 'tmid' || param.key === 'dmid') {
        return { ...param, value: newId };
      }
      return param;
    });

    console.log('Updated Additional Parameters:', this.additionalRequestPayloadParams);
  }
}

private updatePayloadParams(newId: any) {
  if (this.additionalRequestPayloadParams && this.additionalRequestPayloadParams.length > 0) {
    // Creating a new array reference to trigger Angular's change detection
    this.additionalRequestPayloadParams = this.additionalRequestPayloadParams.map(item => {
      // Check if the property 'tmId' exists in this object
      if (item.hasOwnProperty('tmId')) {
        console.log('Found tmId property, updating to:', newId);
        return { ...item, tmId: newId }; // Update the property directly
      }
      return item;
    });

    console.log('Successfully updated params:', this.additionalRequestPayloadParams);
  }
}


// Inside ngOnInit subscription
this.commonService.dmidState$
  .pipe(takeUntil(this.destroying$))
  .subscribe(newId => {
    if (newId) {
      // 1. Create a deep copy from the original @Input
      // Using spread operator to ensure a new reference is created
      const originalInput = this.additionalRequestPayloadParams;

      if (Array.isArray(originalInput)) {
        // If it's an array, map through and update
        this.localAdditionalParams = originalInput.map(item => ({
          ...item,
          tmId: newId // Update tmId while keeping other props like mshLevel4Id
        }));
      } else if (originalInput && typeof originalInput === 'object') {
        // If it's a single object, copy and update
        this.localAdditionalParams = {
          ...originalInput,
          tmId: newId
        };
      } else {
        // Fallback: if input is empty, initialize with the new ID
        this.localAdditionalParams = [{ tmId: newId }];
      }

      console.log('Original Input remains unchanged:', this.additionalRequestPayloadParams);
      console.log('Local Copy updated for Grid:', this.localAdditionalParams);

      // 2. Reload the report
      this.loadReport();
    }
  });

  -----
  private syncLocalParams(newId: any) {
    const original = this._originalParams;

    if (!original) {
      this.localAdditionalParams = [{ tmId: newId }];
      return;
    }

    // Deep copy and update based on the structure seen in logs
    if (Array.isArray(original)) {
      this.localAdditionalParams = original.map(item => ({
        ...item,
        tmId: newId
      }));
    } else if (typeof original === 'object') {
      this.localAdditionalParams = {
        ...original,
        tmId: newId
      };
    }
  }


  private _originalParams: any;
  public localAdditionalParams: any;

  @Input() set additionalRequestPayloadParams(value: any) {
    this._originalParams = value;
    // Initialize the local copy immediately so it's ready for the first render
    this.syncLocalParams(this.reportId);
  }

  ngOnInit() {
    this.commonService.dmidState$
      .pipe(takeUntil(this.destroying$))
      .subscribe(newId => {
        if (newId) {
          this.reportId = newId; // Update local state
          this.syncLocalParams(newId); // Update the local copy
          this.loadReport(); // Trigger the grid refresh
        }
      });
  }


  --------------------------
  @Input() set additionalRequestPayLoad(value: any[]) {
    // 1. Capture the master blueprint from the parent
    this._originalParams = value || [];

    // 2. On first load, localAdditionalParams is a direct clone of the input
    // This ensures it has ALL values (tmId, mshLevel4Id, etc.) exactly as passed.
    this.localAdditionalParams = [...this._originalParams];

    console.log('Initial Load: Complete values received from input', this.localAdditionalParams);
  }


  ngOnInit() {
    this.commonService.dmidState$
      .pipe(takeUntil(this.destroying$))
      .subscribe(newId => {
        if (newId) {
          // Only now do we update the local copy with the new event ID
          this.syncLocalParams(newId);
          this.loadReport(); //
        }
      });
  }


  private syncLocalParams(newId: any) {
    if (!this._originalParams || this._originalParams.length === 0) return;

    // We map through the blueprint to create a fresh copy for the grid
    this.localAdditionalParams = this._originalParams.map(item => {
      // If the object has tmId, we update it; otherwise, we return the object as-is (preserving mshLevel4Id, etc.)
      if (item && typeof item === 'object' && Object.prototype.hasOwnProperty.call(item, 'tmId')) {
        return {
          ...item,    // Preserve all other properties
          tmId: newId // Update with the ID from the event
        };
      }
      return item;
    });
  }


  @Input() set additionalRequestPayloadParams(value: any) {
    this._originalParams = value;

    // On first load, create a clean clone of whatever structure we received
    if (Array.isArray(value)) {
      this.localAdditionalParams = [...value];
    } else if (value && typeof value === 'object') {
      this.localAdditionalParams = { ...value };
    } else {
      this.localAdditionalParams = value;
    }
  }

  private syncLocalParams(newId: any) {
    const original = this._originalParams;

    if (!original) return;

    // 1. If it's an Array, use .map() to create a new reference
    if (Array.isArray(original)) {
      this.localAdditionalParams = original.map(item => {
        if (item && typeof item === 'object' && Object.prototype.hasOwnProperty.call(item, 'tmId')) {
          return { ...item, tmId: newId }; // Preserve all original keys
        }
        return item;
      });
    }
    // 2. If it's a single Object (as seen in image_d7b043.png), update directly
    else if (typeof original === 'object') {
      this.localAdditionalParams = {
          ...original,
          tmId: newId
      };
    }

    console.log('Successfully synced local params:', this.localAdditionalParams);
  }


  --------------
  ngOnInit() {
    // Ensure dataLoaded starts as false
    this.dataLoaded = false;

    forkJoin([
      this.fetchReportDetails(),
      this.fetchSharedUserDetails()
    ]).subscribe({
      next: (results) => {
        // This block only runs once BOTH observables have completed
        console.log('Both API calls finished successfully');
        this.dataLoaded = true;
      },
      error: (err) => {
        console.error('One of the API calls failed', err);
        // Handle error (maybe set dataLoaded to true anyway, or show error message)
      }
    });
  }

  --------------\

  import { forkJoin } from 'rxjs';
  import { tap } from 'rxjs/operators';

  // 1. Function returns the Observable (No .subscribe here!)
  fetchReportDetails() {
    return this.graphqlService.retriveUserReportDetails().pipe(
      tap((response: any) => {
        if (response?.data?.retrieveUserReportDetails) {
          const eligibleReports = response.data.retrieveUserReportDetails;
          eligibleReports.forEach((rpt: any) => {
            this.reports.push({ reportName: rpt.reportName, reportId: rpt.reportId });
          });
        }
      })
    );
  }

  // 2. Function returns the Observable (No .subscribe here!)
  fetchSharedUserDetails() {
    return this.graphqlService.getUserDetailsByMsh4Cd(this.mshLevel4Cds).pipe(
      tap((response: any) => {
        if (response?.data?.getUserDetailsByMsh4Cd) {
          const userDetails = response.data.getUserDetailsByMsh4Cd;
          userDetails.forEach((user: any) => {
            this.mailRecipientList.push({ dlEmail: user.email, dlName: user.userName });
          });
        }
      })
    );
  }

  // 3. Execution in ngOnInit
  ngOnInit() {
    this.dataLoaded = false;

    forkJoin({
      reports: this.fetchReportDetails(),
      users: this.fetchSharedUserDetails()
    }).subscribe({
      next: (val) => {
        console.log('Success! Data collected:', val);
        this.dataLoaded = true; // This will now wait for both
      },
      error: (err) => {
        console.error('Check your API/GraphQL console. Something failed:', err);
      }
    });
  }


  ----------
  import java.util.*;
  import java.util.stream.Collectors;

  public class DataGridMapper {

      /**
       * Updates the keys of grid data based on a column configuration map.
       * * @param reportsData The raw data list (List of Maps)
       * @param colConfigMap Map containing {currentKey -> uiColumnName}
       * @return A new list of maps with updated keys
       */
      public List<Map<String, Object>> mapToUiColumns(
              List<Map<String, Object>> reportsData,
              Map<String, String> colConfigMap) {

          if (reportsData == null || colConfigMap == null) {
              return Collections.emptyList();
          }

          return reportsData.stream()
                  .map(row -> remapRow(row, colConfigMap))
                  .toList(); // Using .toList() (Available in Java 16+)
      }

      private Map<String, Object> remapRow(Map<String, Object> row, Map<String, String> colConfigMap) {
          return row.entrySet().stream()
                  .collect(Collectors.toMap(
                      // Map the key if it exists in config, otherwise keep original
                      entry -> colConfigMap.getOrDefault(entry.getKey(), entry.getKey()),
                      Map.Entry::getValue,
                      (existing, replacement) -> existing, // Merge function to handle collisions
                      LinkedHashMap::new // Maintains the original order of columns
                  ));
      }
  }

