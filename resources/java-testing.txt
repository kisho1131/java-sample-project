ngOnInit(): void {
  this.analyticalReportService.currentReportId$.pipe(
    takeUntil(this.destroying$),
    // switchMap handles the ID change and fetches metadata in order
    switchMap(id => {
      this.reportId = id;
      console.log('State Change Detected: New ID is', id);

      // Fetch column mappings and groupings first
      return forkJoin({
        cols: makeHttpGetRequest(this.httpClient, './api/report/column-mapping', {
          params: { reportType: this.reportType }
        }),
        groupings: makeHttpGetRequest(this.httpClient, './api/report/grouping-attr', {
          params: { reportType: this.reportType }
        })
      });
    })
  ).subscribe({
    next: (response: any) => {
      // 1. Set the Grid Structure
      this.pivotGroupColDefs = this.gridHelperService.getColModelByReportType(
        response.groupings,
        response.cols
      );

      // 2. Trigger data loading now that structure is ready
      this.loadReport();
    },
    error: (err) => console.error(err)
  });
}

---------

import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class CommonService {
  // Use BehaviorSubject to hold the "Current" DMID state
  private dmidSource = new BehaviorSubject<any>(null);

  // Observable that components will subscribe to
  dmidState$ = this.dmidSource.asObservable();

  // Method to update the DMID from AppComponent
  updateDMID(newId: any) {
    this.dmidSource.next(newId);
  }
}

// Inside your DMID change logic
this.commonService.updateDMID(newSelectedId);

ngOnInit() {
  this.commonService.dmidState$
    .pipe(takeUntil(this.destroying$))
    .subscribe(id => {
      if (id) {
        console.log('DMID Change Detected:', id);
        this.reportId = id; //
        this.loadReport();  // Re-trigger the data fetch
      }
    });
}


ngOnInit() {
  this.commonService.dmidState$
    .pipe(takeUntil(this.destroying$))
    .subscribe(newId => {
      if (newId) {
        this.reportId = newId; //

        // Update the TMID/DMID inside the additional parameters array
        this.updatePayloadParams(newId);

        // Reload the report with the new parameters
        this.loadReport(); //
      }
    });
}

private updatePayloadParams(newId: any) {
  if (this.additionalRequestPayloadParams && this.additionalRequestPayloadParams.length > 0) {
    // We create a new array reference to ensure Angular detection triggers
    this.additionalRequestPayloadParams = this.additionalRequestPayloadParams.map(param => {
      // Check for your specific key (e.g., 'tmid', 'dmid', or 'id')
      if (param.key === 'tmid' || param.key === 'dmid') {
        return { ...param, value: newId };
      }
      return param;
    });

    console.log('Updated Additional Parameters:', this.additionalRequestPayloadParams);
  }
}

private updatePayloadParams(newId: any) {
  if (this.additionalRequestPayloadParams && this.additionalRequestPayloadParams.length > 0) {
    // Creating a new array reference to trigger Angular's change detection
    this.additionalRequestPayloadParams = this.additionalRequestPayloadParams.map(item => {
      // Check if the property 'tmId' exists in this object
      if (item.hasOwnProperty('tmId')) {
        console.log('Found tmId property, updating to:', newId);
        return { ...item, tmId: newId }; // Update the property directly
      }
      return item;
    });

    console.log('Successfully updated params:', this.additionalRequestPayloadParams);
  }
}


// Inside ngOnInit subscription
this.commonService.dmidState$
  .pipe(takeUntil(this.destroying$))
  .subscribe(newId => {
    if (newId) {
      // 1. Create a deep copy from the original @Input
      // Using spread operator to ensure a new reference is created
      const originalInput = this.additionalRequestPayloadParams;

      if (Array.isArray(originalInput)) {
        // If it's an array, map through and update
        this.localAdditionalParams = originalInput.map(item => ({
          ...item,
          tmId: newId // Update tmId while keeping other props like mshLevel4Id
        }));
      } else if (originalInput && typeof originalInput === 'object') {
        // If it's a single object, copy and update
        this.localAdditionalParams = {
          ...originalInput,
          tmId: newId
        };
      } else {
        // Fallback: if input is empty, initialize with the new ID
        this.localAdditionalParams = [{ tmId: newId }];
      }

      console.log('Original Input remains unchanged:', this.additionalRequestPayloadParams);
      console.log('Local Copy updated for Grid:', this.localAdditionalParams);

      // 2. Reload the report
      this.loadReport();
    }
  });

  -----
  private syncLocalParams(newId: any) {
    const original = this._originalParams;

    if (!original) {
      this.localAdditionalParams = [{ tmId: newId }];
      return;
    }

    // Deep copy and update based on the structure seen in logs
    if (Array.isArray(original)) {
      this.localAdditionalParams = original.map(item => ({
        ...item,
        tmId: newId
      }));
    } else if (typeof original === 'object') {
      this.localAdditionalParams = {
        ...original,
        tmId: newId
      };
    }
  }


  private _originalParams: any;
  public localAdditionalParams: any;

  @Input() set additionalRequestPayloadParams(value: any) {
    this._originalParams = value;
    // Initialize the local copy immediately so it's ready for the first render
    this.syncLocalParams(this.reportId);
  }

  ngOnInit() {
    this.commonService.dmidState$
      .pipe(takeUntil(this.destroying$))
      .subscribe(newId => {
        if (newId) {
          this.reportId = newId; // Update local state
          this.syncLocalParams(newId); // Update the local copy
          this.loadReport(); // Trigger the grid refresh
        }
      });
  }


  --------------------------
  @Input() set additionalRequestPayLoad(value: any[]) {
    // 1. Capture the master blueprint from the parent
    this._originalParams = value || [];

    // 2. On first load, localAdditionalParams is a direct clone of the input
    // This ensures it has ALL values (tmId, mshLevel4Id, etc.) exactly as passed.
    this.localAdditionalParams = [...this._originalParams];

    console.log('Initial Load: Complete values received from input', this.localAdditionalParams);
  }


  ngOnInit() {
    this.commonService.dmidState$
      .pipe(takeUntil(this.destroying$))
      .subscribe(newId => {
        if (newId) {
          // Only now do we update the local copy with the new event ID
          this.syncLocalParams(newId);
          this.loadReport(); //
        }
      });
  }


  private syncLocalParams(newId: any) {
    if (!this._originalParams || this._originalParams.length === 0) return;

    // We map through the blueprint to create a fresh copy for the grid
    this.localAdditionalParams = this._originalParams.map(item => {
      // If the object has tmId, we update it; otherwise, we return the object as-is (preserving mshLevel4Id, etc.)
      if (item && typeof item === 'object' && Object.prototype.hasOwnProperty.call(item, 'tmId')) {
        return {
          ...item,    // Preserve all other properties
          tmId: newId // Update with the ID from the event
        };
      }
      return item;
    });
  }
